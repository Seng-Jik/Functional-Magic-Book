# Lambda算术

`Lambda演算之于函数式编程，如同力学三定律之于经典物理学。—— Chuigda·Whitegive`

## 一些前置事项

1. 本章使用了零知识证明，因此阅读本章不需要任何的前置知识。
2. 若想完成本章所作的演示，请先阅读`工具与环境`一章与`Racket`相关的内容。

## 什么是Lambda算术

Lambda演算是一种自洽的计算模型。在之前的例子中，我们有提到过lambda是一种匿名函数。那么，Lambda演算的计算规则是什么？我们怎么用它来构建主流编程语言中常用的操作？

我们首先来解决第一个问题：

### 算术规则

<!--
废案
Lambda演算是一种图灵完备的计算模型，同时它也比图灵机模型更简单
-->
Lambda演算是一种简单的计算模型，简单这一特点体现在Lambda演算只有三种规则。
即



<!--传统手艺之虚空起序对g with lambda calculus -->
(define (cons a b)
  (lambda (selector)
    (case selector
      [(1) a]
      [(2) b])))#lang racket
;; dc



;; 用类似的办法可以做很多有趣的事情，你会发现(struct)根本就没有必要
;; kiana里的很多结构就是这么构造的
;; 说起来我们还没讲到car/cdr/cons?```

<!--

我觉得我们需要假设我们之前几章教了什么？（

What we've taught? Let me think...

(load-book 'sicp)
(import-chapater 'sicp-ch-1)

递归函数再lambda之后;
值，函数和lambda，递归函数，高阶函数；如何运用这些特性写程序

接下来我们来看一下lambda calculus的条文里有什么

  α (Shift+F6 rename) lambda x.x -> "x => y" lambda y.y 
  β (Function apply)  (lambda x.M)y = M[x = y]
  η // not important anyway.

3 rules

不过实际上呢，SICP的beta reduction是在讲函数之后接着就讲了，
这个规则作为一个学习工具非常有用

;; 我甚至觉得lambda calculus和church counting之类不一定要单独开一章；
;; 毕竟本书的主旨是让编程小白和函数式入门玩家快速掌握F的是
;; lambda calculus的理想很伟大，现实很残忍是

-->

```racket
beta reduction:

((lambda (x) (* x x)) 5) => (* 5 5) => 25

((lambda (square)
  (square 3))
 (lambda (x) (* x x))
)
=> ((lambda (x) (* x x) 3)
=> (* 3 3)
=> 9

```
