# 类型

类型是这本书的核心内容之一——对于很多编程语言也是一样。

我们在学习编程的过程中，很容易会接触到类型，也许是编译器报错时的`expected xxx, found xxx`，也许是运行时的`TypeError`——这是动态语言的报错。

但是，在我们开始研究类型之前，我们要问一个小问题：类型在哪里？

让我们从之前讲过的内容开始——别说你已经忘了:)

在F#中，我们要对一个变量赋值，我们会怎么做？

```fs
let mutable i = 0
```

我们将0赋值给了一个可变变量`i`。

为了把i的类型限制在某一个类型，我们可以稍稍的对它加一些拓展：

```fs
let mutable i: int = 0
```

我们将0赋值给了`int`类型的变量`i`。

我们可以尝试一下将其它类型的值赋值给i：

```fs
i <- "string"
```

**注意！**切勿尝试重新使用`let mutable i = "string"`来赋值，因为这会用一个新i覆盖掉i而不是对i赋值

我们得到了错误：`error FS0001: 此表达式应具有类型 “int” 而此处具有类型 “string”`

慢着慢着——或许一些爱尝试的读者已经发现了不妥之处：“我没有限制i的值呀，为什么重新赋值也会报错呢？”

这是因为F#是一个**静态类型**的编程语言，即使我们没有刻意的去规定变量的值，F#也会尽可能猜出一个合理的类型，然后将变量的类型固定下来，我们称这种行为叫**Local TypeInference（局部类型推导）**。

当然，F#不止能做到**局部类型推导**，它还能做到**全局类型推导**（也叫**全程序类型推导**），这是F#的一部分比其它一些编程语言强的地方，也是我们选用F#作为教学语言的一部分原因。

<!-- TODO -->

## 前置知识：集合

为了解释这个重要的问题，我会先向你们普及集合论的相关知识，这涉及到之后的章节能否看懂——开玩笑的，如果不喜欢晦涩难懂的数学知识，可以直接跳到下一章。

<!-- TODO: 集合论 -->

## 类型与集合的关系

<!-- 那么，类型到底是什么？为了解释这个问题，我们需要引入数学的根基——“集合论”。 -->

<!-- 首先，让我们回忆一下，我们第一次接触过的类型是什么：是`int`，是`float`，是`byte`这样的基本类型。 -->

我们说：x这个值是byte类型的，它有0到256这个取值范围。

让我们我们用F#代码来描述这个逻辑：

```fs
let x: byte
```

这不是一个完整的F#表达式，为了让它通过编译器的检查，我们还需要将其补充完整：

```fs
let x: byte = 0
```

这句话用集合论来描述就是：`x∈{0, 1, ..., 256}`(x属于`{0, 1, ..., 256}`这个数集)。

发现了吗，在这个过程中，我们使用了`∈`来描述变量与类型之间的属于关系

<!-- 那么，我们在讨论“一个int类型的值”时，我们在讨论什么 -->
