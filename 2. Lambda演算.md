# Lambda 演算

## 三条基本规则

我们可以使用以下三条规则表示任何计算过程：

1. 值可以具有一个名字，当写上名字时，代表这个值。
2. 类似表达式 “λx.x+1”，它表示一个数学上的函数“f(x) = x + 1”，这个函数是一个值。
3. 如果我们具有一个值 f，f的值为“λx.x+1”，那么表达式“f 1”或“(λx.x+1) 1”的值就相当于将1带入x后进行计算，类似数学上从“f(x) = x + 1”带入“x = 1”后得到“f(1) = 1 + 1”，最终得到的结果为2，此结果也是一个值，也可具有一个名字。

现在，我们有了一个强大的工具，用于表示计算的过程了。

以下是一个示例，这个例子将会计算1、2、3三个值的平均值：

```lambda
(λx. (λy. (λz. (x + y + z) / 3))) 1 2 3
```

下面这段代码使用F#编程语言写成，乍一看似乎和lambda演算的写法有很大不同，但实际上只是把λ符号换成了fun，把点号换成了->而已。

```fsharp
(fun x -> fun y -> fun z -> (x + y + z) / 3.0) 1.0 2.0 3.0
```

但实际上这一段代码并没有指示计算机输出结果，如果想输出结果，可以写成这样：

```fsharp
let a = (fun x -> fun y -> fun z -> (x + y + z) / 3.0) 1.0 2.0 3.0
printfn "%A" a
```

## 那么，F#编程语言中的let是什么呢？

在上文中，在F#编程语言里，我们发现了一个let关键字，似乎是把右面那一长串表达式绑定到了名字a上，看起来好像这是编程语言固有的机制，不是三条规则内的东西，但实际上let关键字只不过是三条规则的衍生品而已。

观察以下F#编程语言代码和λ演算表达式：

```fsharp
let a = 1 + 2 + 3
a * 2
```

```lambda
(λa. a * 2) (1 + 2 + 3)
```

似乎两者起到了同样的作用，计算的行为一致，也确实都把1 + 2 + 3的结果绑定到了a上。

假设在λ演算的环境中已经存在名字let，它的值如下：

```lambda
λx. (λcontinuation. continuation x)
```

那么，我们可以写出以下的λ演算表达式：

```lambda
let (1 + 2 + 3) (λa. a * 2)
```

是不是看起来就像F#代码一样了呢？

然而F#编程语言中let的完整写法是这样的：

```fsharp
let a = 1 + 2 + 3 in a * 2
```

而实际上，和F#编程语言中以下写法等价：

```lambda
(fun a -> a * 2) (1 + 2 + 3)
```

当然，我们也可以定义一个函数，由于let是关键字，所以这里我们定义为bind：

```fsharp
let bind = fun x -> fun continuatio -> continuation x
bind (1 + 2 + 3) (fun a -> a * 2)
```

看起来是不是和上面λ演算表达式中的写法所表达的内容一致呢？

总结下来，let关键字的工作方式无非也就是以下两个步骤：

```fsharp
let a = 1 + 2 + 3 in a * 2
```

1. 把这in之后所有的计算打包成一个函数，并且这个函数有一个参数，参数的名字为“=”号左边的名字，在这个例子中，“a * 2”被打包成了函数“(fun a -> a * 2)”。
2. “=”号右边的表达式被包上括号，放到了步骤1打包出的函数的右边，在当前这个例子里，变成了“(fun a -> a * 2) (1 + 2 + 3)”。

## printfn的未解之谜

观察以下F#编程语言的代码：

```fsharp
let a = 1
printfn "%A" a
let b = 1
printfn "%A" b
```

似乎我们很难写出它的λ演算表达式，就好像连续两个let，中间隔了一个printfn“语句”一样，首先我们写出它的完整形式。

```fsharp
let a = 1 in 
do printfn "%A" a in
let b = 1 in
printfn "%A"
```

这时候你可能会想了，do又是个什么玩意儿？
可能写成以下形式，你就会很熟悉了：

```fsharp
let a = 1 in
let something = printfn "%A" a in
let b = 2 in
printfn "%A" b
```

尽管printfn看起来像是语句，但它实际上是一个返回“()”的函数，尽管“()”不是一个数字，但它在F#编程语言中仍然是一个值，代表“什么也没有”。

